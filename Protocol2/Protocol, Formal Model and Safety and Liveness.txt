Discretize time into slots which we assume to be totally ordered. SLOT == NAT
Each party has access to a clock which they can query for the current slot, flooding network they can use to flood messages to each other and a lottery funcitonality they can query to check 
if they are the winner of a slot. Party wins the lotter for a slot is a baker of this slot 
A block contains a slot number, a hash of the predecsessor, an identifier of the baker and a signature.  
These are the content of messages send through the flooding network in teh protocol. 
Each party maintains a block tre that initially only contains a single blcok called the genesis block. when a block b is added to the block tree it will be added as a sucessor to the block in the tree with a hash that matches the predecessor of b. A path originating at the genesis block in a block tree is called a chain.

The protocol proceeds in slots where each party will do the following for a slot:
-> collect all previous blocks that they have received since the last round through the flooding network and add these to their block tree if the signature is avalid and the identifier of the bock corresponds to a winning party for the round. -> corresponds to winning party id 
-> Evaluate the lottery to check if they are a winner of this round. If they win this slot they will:
-> -> Calculate lonest chain disregarding blcoks with a higher slot than the current slot. if there are multiple longest chains tie breaker used but is insignificant in this case
-> -> Create a new block that will include a hash to the head of their best chain, the current slot, their identity and their signature.
-> -> Flood this new block using the flooding netowkr.

Protocol ensures agreement on the longgest chain when removing a few blocks from the head of this chain. It is for the chains calculated in this way we wish to ensure both safety and liveness by ensuring that the best chain of any party grows., that honest blocks regularly appended to this hcain and that this chain is both consistent amount parties na dpersistent when the protocol progresses (common prefix).

Record, representing hashblock 
pred : Hash, Slot: Slot, TXS :TXS, bid : Party

Protocol has initial block GenesisBlock :: Block that chains END in 
assume to have honest baker id and slot as 0 

Valid Chain : All blocks in the chain need to be valid. A block b is valid 
if winner bid b slot b = True, and 
pred of a block contains a hash that is equal to that of the predecessor in the chain and the 
chain ends in the genesis block. Slot decreases as chain gets to genesis valid_chain :: Chain => Bool

Correctness conditions for block 
Tree0 :: T
extendTree :: T => Block => T
allBlocks :: T => SEQ Block
bestChain : Slot => T => Chain

definition for instantiated tree 
extendable tree
best chain is valid
Optimal chain
Self contained chain

Local state record id : Party, tT : TreeType, tree : TT}